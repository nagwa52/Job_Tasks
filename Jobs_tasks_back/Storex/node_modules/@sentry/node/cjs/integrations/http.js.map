{"version":3,"file":"http.js","sources":["../../../src/integrations/http.ts"],"sourcesContent":["import { getCurrentHub, Hub } from '@sentry/core';\nimport { EventProcessor, Integration, Span, TracePropagationTargets } from '@sentry/types';\nimport {\n  dynamicSamplingContextToSentryBaggageHeader,\n  fill,\n  isMatchingPattern,\n  logger,\n  parseSemver,\n} from '@sentry/utils';\nimport * as http from 'http';\nimport * as https from 'https';\n\nimport { NodeClientOptions } from '../types';\nimport {\n  cleanSpanDescription,\n  extractUrl,\n  isSentryRequest,\n  normalizeRequestArgs,\n  RequestMethod,\n  RequestMethodArgs,\n} from './utils/http';\n\nconst NODE_VERSION = parseSemver(process.versions.node);\n\n/**\n * The http module integration instruments Node's internal http module. It creates breadcrumbs, transactions for outgoing\n * http requests and attaches trace data when tracing is enabled via its `tracing` option.\n */\nexport class Http implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Http';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Http.id;\n\n  /**\n   * @inheritDoc\n   */\n  private readonly _breadcrumbs: boolean;\n\n  /**\n   * @inheritDoc\n   */\n  private readonly _tracing: boolean;\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(options: { breadcrumbs?: boolean; tracing?: boolean } = {}) {\n    this._breadcrumbs = typeof options.breadcrumbs === 'undefined' ? true : options.breadcrumbs;\n    this._tracing = typeof options.tracing === 'undefined' ? false : options.tracing;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(\n    _addGlobalEventProcessor: (callback: EventProcessor) => void,\n    setupOnceGetCurrentHub: () => Hub,\n  ): void {\n    // No need to instrument if we don't want to track anything\n    if (!this._breadcrumbs && !this._tracing) {\n      return;\n    }\n\n    const clientOptions = setupOnceGetCurrentHub().getClient()?.getOptions() as NodeClientOptions | undefined;\n\n    const wrappedHandlerMaker = _createWrappedRequestMethodFactory(\n      this._breadcrumbs,\n      this._tracing,\n      clientOptions?.tracePropagationTargets,\n    );\n\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const httpModule = require('http');\n    fill(httpModule, 'get', wrappedHandlerMaker);\n    fill(httpModule, 'request', wrappedHandlerMaker);\n\n    // NOTE: Prior to Node 9, `https` used internals of `http` module, thus we don't patch it.\n    // If we do, we'd get double breadcrumbs and double spans for `https` calls.\n    // It has been changed in Node 9, so for all versions equal and above, we patch `https` separately.\n    if (NODE_VERSION.major && NODE_VERSION.major > 8) {\n      // eslint-disable-next-line @typescript-eslint/no-var-requires\n      const httpsModule = require('https');\n      fill(httpsModule, 'get', wrappedHandlerMaker);\n      fill(httpsModule, 'request', wrappedHandlerMaker);\n    }\n  }\n}\n\n// for ease of reading below\ntype OriginalRequestMethod = RequestMethod;\ntype WrappedRequestMethod = RequestMethod;\ntype WrappedRequestMethodFactory = (original: OriginalRequestMethod) => WrappedRequestMethod;\n\n/**\n * Function which creates a function which creates wrapped versions of internal `request` and `get` calls within `http`\n * and `https` modules. (NB: Not a typo - this is a creator^2!)\n *\n * @param breadcrumbsEnabled Whether or not to record outgoing requests as breadcrumbs\n * @param tracingEnabled Whether or not to record outgoing requests as tracing spans\n *\n * @returns A function which accepts the exiting handler and returns a wrapped handler\n */\nfunction _createWrappedRequestMethodFactory(\n  breadcrumbsEnabled: boolean,\n  tracingEnabled: boolean,\n  tracePropagationTargets: TracePropagationTargets | undefined,\n): WrappedRequestMethodFactory {\n  // We're caching results so we dont have to recompute regexp everytime we create a request.\n  const urlMap: Record<string, boolean> = {};\n  const shouldAttachTraceData = (url: string): boolean => {\n    if (tracePropagationTargets === undefined) {\n      return true;\n    }\n\n    if (urlMap[url]) {\n      return urlMap[url];\n    }\n\n    urlMap[url] = tracePropagationTargets.some(tracePropagationTarget =>\n      isMatchingPattern(url, tracePropagationTarget),\n    );\n\n    return urlMap[url];\n  };\n\n  return function wrappedRequestMethodFactory(originalRequestMethod: OriginalRequestMethod): WrappedRequestMethod {\n    return function wrappedMethod(this: typeof http | typeof https, ...args: RequestMethodArgs): http.ClientRequest {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const httpModule = this;\n\n      const requestArgs = normalizeRequestArgs(this, args);\n      const requestOptions = requestArgs[0];\n      const requestUrl = extractUrl(requestOptions);\n\n      // we don't want to record requests to Sentry as either breadcrumbs or spans, so just use the original method\n      if (isSentryRequest(requestUrl)) {\n        return originalRequestMethod.apply(httpModule, requestArgs);\n      }\n\n      let requestSpan: Span | undefined;\n      let parentSpan: Span | undefined;\n\n      const scope = getCurrentHub().getScope();\n\n      if (scope && tracingEnabled) {\n        parentSpan = scope.getSpan();\n\n        if (parentSpan) {\n          requestSpan = parentSpan.startChild({\n            description: `${requestOptions.method || 'GET'} ${requestUrl}`,\n            op: 'http.client',\n          });\n\n          if (shouldAttachTraceData(requestUrl)) {\n            const sentryTraceHeader = requestSpan.toTraceparent();\n            __DEBUG_BUILD__ &&\n              logger.log(\n                `[Tracing] Adding sentry-trace header ${sentryTraceHeader} to outgoing request to \"${requestUrl}\": `,\n              );\n\n            requestOptions.headers = {\n              ...requestOptions.headers,\n              'sentry-trace': sentryTraceHeader,\n            };\n\n            if (parentSpan.transaction) {\n              const dynamicSamplingContext = parentSpan.transaction.getDynamicSamplingContext();\n              const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(dynamicSamplingContext);\n\n              let newBaggageHeaderField;\n              if (!requestOptions.headers || !requestOptions.headers.baggage) {\n                newBaggageHeaderField = sentryBaggageHeader;\n              } else if (!sentryBaggageHeader) {\n                newBaggageHeaderField = requestOptions.headers.baggage;\n              } else if (Array.isArray(requestOptions.headers.baggage)) {\n                newBaggageHeaderField = [...requestOptions.headers.baggage, sentryBaggageHeader];\n              } else {\n                // Type-cast explanation:\n                // Technically this the following could be of type `(number | string)[]` but for the sake of simplicity\n                // we say this is undefined behaviour, since it would not be baggage spec conform if the user did this.\n                newBaggageHeaderField = [requestOptions.headers.baggage, sentryBaggageHeader] as string[];\n              }\n\n              requestOptions.headers = {\n                ...requestOptions.headers,\n                // Setting a hader to `undefined` will crash in node so we only set the baggage header when it's defined\n                ...(newBaggageHeaderField && { baggage: newBaggageHeaderField }),\n              };\n            }\n          } else {\n            __DEBUG_BUILD__ &&\n              logger.log(\n                `[Tracing] Not adding sentry-trace header to outgoing request (${requestUrl}) due to mismatching tracePropagationTargets option.`,\n              );\n          }\n\n          const transaction = parentSpan.transaction;\n          if (transaction) {\n            transaction.metadata.propagations += 1;\n          }\n        }\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return originalRequestMethod\n        .apply(httpModule, requestArgs)\n        .once('response', function (this: http.ClientRequest, res: http.IncomingMessage): void {\n          // eslint-disable-next-line @typescript-eslint/no-this-alias\n          const req = this;\n          if (breadcrumbsEnabled) {\n            addRequestBreadcrumb('response', requestUrl, req, res);\n          }\n          if (tracingEnabled && requestSpan) {\n            if (res.statusCode) {\n              requestSpan.setHttpStatus(res.statusCode);\n            }\n            requestSpan.description = cleanSpanDescription(requestSpan.description, requestOptions, req);\n            requestSpan.finish();\n          }\n        })\n        .once('error', function (this: http.ClientRequest): void {\n          // eslint-disable-next-line @typescript-eslint/no-this-alias\n          const req = this;\n\n          if (breadcrumbsEnabled) {\n            addRequestBreadcrumb('error', requestUrl, req);\n          }\n          if (tracingEnabled && requestSpan) {\n            requestSpan.setHttpStatus(500);\n            requestSpan.description = cleanSpanDescription(requestSpan.description, requestOptions, req);\n            requestSpan.finish();\n          }\n        });\n    };\n  };\n}\n\n/**\n * Captures Breadcrumb based on provided request/response pair\n */\nfunction addRequestBreadcrumb(event: string, url: string, req: http.ClientRequest, res?: http.IncomingMessage): void {\n  if (!getCurrentHub().getIntegration(Http)) {\n    return;\n  }\n\n  getCurrentHub().addBreadcrumb(\n    {\n      category: 'http',\n      data: {\n        method: req.method,\n        status_code: res && res.statusCode,\n        url,\n      },\n      type: 'http',\n    },\n    {\n      event,\n      request: req,\n      response: res,\n    },\n  );\n}\n"],"names":[],"mappings":";;;;;;;;;;AAsBA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoEA;;AAEA;;AAKA;;;;;;;;;AASA;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiIA;;AAEA;;;AAGA;;;;;;;;;;;;;;;;;;;;;AAqBA;;"}